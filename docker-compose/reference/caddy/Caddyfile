{
  # debug
  https_port  {$SITE_PORT}
  auto_https  disable_redirects
  default_sni {$DEFAULT_SNI}
  admin       :{$ADMIN_PORT}
  # /metrics on http://{$SITE_DOMAIN}:{$ADMIN_PORT}/metrics
}

{$SITE_DOMAIN}:{$SITE_PORT} {

  tls {$CERT_MANAGER_EMAIL} {
    import /data/conf.d/lets-encrypt-dns.conf
  }

  encode zstd gzip
  header /* Server "p6proxy/1.0.0"

  @baseUrlParam {
    maxmind_geolocation {
        db_path "/data/conf.d/{$MAXMIND_GEO_DB}"
        # See https://dev.maxmind.com/geoip/legacy/codes/iso3166/
	    deny_countries RU CN
    }
    query baseUrl=*
  }

  route @baseUrlParam {

    # Ensure we have a valid p6auth JWT
    jwt_valid {
      pem_keypath /data/conf.d/{$P6AUTH_PUBLIC_KEY_FILE}
      has_claim iss http://amalto.com
      has_claim jti b2jwt-1.0.1
      clockskew "3m"
    }

    # Split baseUrl parameter into component parts: scheme, host, colon, port and path
    vars_regex {
      name baseurl
      source {http.request.uri.query.baseUrl}
      pattern "(?P<scheme>https?:\/\/)(?P<host>[^:^\/]*)(?P<colon>:)?(?P<port>\d*[^\/])?(?P<path>.*[^\/])?"
    }

    @httpsTarget {
        expression string({http.vars_regex.baseurl.scheme}).startsWith('https')
    }

    @httpTarget {
        expression string({http.vars_regex.baseurl.scheme}).startsWith('http:')
    }

   # When using placeholders as arguments to reverse_proxy you have to specify host:port
   # However a port may not have been specified in the request...
    vars_regex {
        name default_port
        source {http.vars_regex.baseurl.port}
        pattern ".*"
    }

    # Force any missing port in the https baseUrl to be 443 using this vars_regex trick:
    vars_regex @httpsTarget {
        name default_port
        source "443"
        pattern ".*"
        overwrite false
    }

    # Force any missing port in the http baseUrl to be 80 using this vars_regex trick:
    vars_regex @httpTarget {
        name default_port
        source "80"
        pattern ".*"
        overwrite false
    }

    # ##########################################################################################

    # Validate proxy target is not blocked and allowed... extend this matcher section as required

    # External block lists generated by scripts using external resources
    @block_list {
        not {
            not {
                import /data/conf.d/bad-user-agent-rules.conf
            }
            not {
                import /data/conf.d/bad-referer-rules.conf
            }
        }
    }
    rewrite @block_list /bad-actor

    # Block attempts to proxy to another of our proxy instances
    @block_proxy_proxy {
      expression string({http.vars_regex.baseurl.host}).matches('devproxy.amalto.io|stagingproxy.amalto.io|proxy.amalto.io')
    }
    rewrite @block_proxy_proxy /bad-actor

    # Block attempts to proxy to this instance on either SITE_PORT or ADMIN_PORT (even via docker bridge networking!)
    @block_self_proxy1 {
      expression (string({http.vars_regex.baseurl.host}) == '{$DEFAULT_SNI}' && string({http.vars_regex.default_port.match1}) == '{$SITE_PORT}') || (string({http.vars_regex.baseurl.host}) == '{$SITE_DOMAIN}' && string({http.vars_regex.default_port.match1}) == '{$SITE_PORT}') || (string({http.vars_regex.baseurl.host}) == 'host.docker.internal' && string({http.vars_regex.default_port.match1}) == '{$SITE_PORT}') || (string({http.vars_regex.baseurl.host}) == 'localhost' && string({http.vars_regex.default_port.match1}) == '{$SITE_PORT}') || (string({http.vars_regex.baseurl.host}) == '172.17.0.1' && string({http.vars_regex.default_port.match1}) == '{$SITE_PORT}')
    }
    rewrite @block_self_proxy1 /bad-actor
    @block_self_proxy2 {
      expression (string({http.vars_regex.baseurl.host}) == '{$DEFAULT_SNI}' && string({http.vars_regex.default_port.match1}) == '{$ADMIN_PORT}') || (string({http.vars_regex.baseurl.host}) == '{$SITE_DOMAIN}' && string({http.vars_regex.default_port.match1}) == '{$ADMIN_PORT}') || (string({http.vars_regex.baseurl.host}) == 'host.docker.internal' && string({http.vars_regex.default_port.match1}) == '{$ADMIN_PORT}') || (string({http.vars_regex.baseurl.host}) == 'localhost' && string({http.vars_regex.default_port.match1}) == '{$ADMIN_PORT}') || (string({http.vars_regex.baseurl.host}) == '172.17.0.1' && string({http.vars_regex.default_port.match1}) == '{$ADMIN_PORT}')
    }
    rewrite @block_self_proxy2 /bad-actor

    # Ensure proxy target is allowed - we'll need to expand the domain wildcards in future as p6 developers host their own instances
    @notallowedlist {
      not {
        expression string({http.vars_regex.baseurl.host}).matches('.*(platform6.io|amalto.com|amalto.io|b2box.com)|localhost|host.docker.internal|172.17.0.1|p6core')
      }
      not {
          import /data/conf.d/allowed-targets-expression.conf
      }
    }
    rewrite @notallowedlist /bad-actor

    # ##########################################################################################

    respond /bad-actor 403

    # Rewrite as baseUrl:path + original url path
    rewrite {http.vars_regex.baseurl.path}{http.request.uri.path}

    # Finally... proxy the request

    # https
    reverse_proxy @httpsTarget {http.vars_regex.baseurl.host}:{http.vars_regex.default_port.match1} {
      transport http {
        tls
        # Ignore bad certs on the targets
        tls_insecure_skip_verify
        dial_timeout 5s
        # Bug in 2.2.1 can't set this
        # response_header_timeout 3s
      }
      header_up Host {http.reverse_proxy.upstream.hostport}
    }
    # http
    reverse_proxy @httpTarget {http.vars_regex.baseurl.host}:{http.vars_regex.default_port.match1} {
      transport http {
        dial_timeout 5s
        # Bug in 2.2.1 can't set this
        # response_header_timeout 3s
      }
      header_up Host {http.reverse_proxy.upstream.hostport}
    }
  }

  import /data/conf.d/runlocal-bucket-proxy.conf

  # Format logs for fail2ban to monitor
  log {
    # level debug
      output file /data/logs/access.log {
      roll_size 1gb
      roll_keep 5
      roll_keep_for 720h
    }
    format single_field common_log
  }
}
